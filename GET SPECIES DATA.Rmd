#####
PLASMAN CHARLIE
2023
#####

###
PARTIE 1 : PREDATION DIFFERENTIELLE ET SIGNATURE ALIMENTAIRE
###

```{r LOAD DATASET}

setwd("/Users/charlieplasman/Desktop/Mémoire /HSM/Personal data/Species data")
data = read.csv("diet_data.csv")

```

```{r CLEAN DATA}

# Load data for the 17 predator species
selected_species = c("Pygoscelis adeliae", "Aptenodytes forsteri", "Aptenodytes patagonicus", "Eudyptes chrysolophus", 
                       "Eudyptes schlegeli", "Thalassoica antarctica", "Procellaria aequinoctialis", "Diomedea exulans",
                       "Thalassarche melanophris", "Thalassarche chrysostoma", "Phoebetria fusca", "Phoebetria palpebrata", 
                       "Arctocephalus gazella", "Lobodon carcinophaga","Mirounga leonina", "Leptonychotes weddellii", "Megaptera novaeangliae")
data_pred = data[data$predator_name %in% selected_species, ]

library(dplyr)

#library(lubridate)
#data_rec <- data_pred %>%
  #mutate(observation_date_start = as.Date(observation_date_start)) %>%
  #filter(year(observation_date_start) >= 1990)

# Supprimer données agrégées pour éviter double-comptage
data_ind = data_pred[data_pred$prey_is_aggregate != "Y", ]

# Sélectionner les variables souhaitées
variables = c("predator_name","prey_name","source_id","predator_sample_count",
              "predator_sample_id","fraction_occurrence","identification_method",
              "prey_worms_class","prey_worms_family","prey_worms_genus")
data_var = data_ind[variables]

# Supprimer les NA 
data_comp= data_var[complete.cases(data_var$predator_sample_count), ]
data_comp= data_comp[complete.cases(data_comp$identification_method), ]
data_comp= data_comp[complete.cases(data_comp$fraction_occurrence), ]
data_comp= data_comp[data_comp$fraction_occurrence != 0,]

```

```{r GET DATA TO INDIVIDUAL LEVEL}

# Create new IDs
data_comp$merged_column <- paste(data_comp$source_id, data_comp$predator_sample_id, sep = "")
IDs <- unique(data_comp$merged_column)

# Modifier la colonne spécifique dans le dataframe
data_comp <- data_comp %>%
  mutate(prey_worms_class = ifelse(prey_worms_class == "Teleostei", "Actinopterygii", prey_worms_class))

resultat <- data.frame()  # Empty dataframe to store the results

for (i in IDs) {
  # Select rows corresponding to the identifier
  lignes <- subset(data_comp, merged_column == i)
  
  # Loop over the rows
  for (j in 1:nrow(lignes)) {
    # Obtain the multiplicator
    multiplicateur <- round(lignes$predator_sample_count[j] * lignes$fraction_occurrence[j], 0)
    
    # Repeat the row based on the multiplicator
    for (k in 1:multiplicateur) {
      # Add the row to the resultat dataframe
      resultat <- rbind(resultat, lignes[j, ])
    }
  }
}

# Afficher le résultat
print(resultat)

write.csv(resultat, file ="indiv_diet_data.csv")

```

```{r DATA OVERVIEW - NEW STARTPOINT}

setwd("/Users/charlieplasman/Desktop/Mémoire /HSM/Personal data/Species data")
resultat = read.csv("indiv_diet_data.csv")

```
```{r DATA OVERVIEW}

prey_species = unique(resultat$prey_name)
prey_class = unique(resultat$prey_worms_class)
# Compter le nombre d'individus par genre de proie
nb_prey_class <- table(resultat$prey_worms_class)
# Afficher les résultats
print(nb_prey_class)
# Créer le graphique barplot en spécifiant les options
barplot(nb_prey_class, 
        las = 2, 
        cex.names = 0.7, 
        main = "Nombre d'individus par classe de proie",
        xlab = "Classe de proie",   
        ylab = "Nombre d'individus",
        ylim = c(0, max(nb_prey_class)),
        cex.axis = 0.8,
        cex.main = 1.2,
        cex.lab = 0.9
)

# Liste des classes de proie à considérer
classes_proie <- c("Actinopterygii", "Malacostraca", "Cephalopoda")

# Filtrer les données en ne considérant que les lignes avec prey_worms_class n'appartenant pas à la liste des classes_proie
donnees_filtrees_autres <- subset(resultat, !(prey_worms_class %in% classes_proie))

# Calculer le nombre d'individus par famille de proie uniquement pour les données filtrées autres
nb_prey_family_filtrees_autres <- table(donnees_filtrees_autres$prey_worms_family)

# Afficher le graphe pour les données filtrées autres
barplot(nb_prey_family_filtrees_autres, las = 2, cex.names = 0.7, 
        main = "Nombre d'individus par famille de proie (Autres classes)",
        xlab = "Genre de proie", ylab = "Nombre d'individus")

# Boucle pour filtrer les données et afficher le graphe pour chaque classe de proie
for (classe in classes_proie) {
  # Filtrer les données en ne considérant que les lignes avec prey_worms_class égale à la classe actuelle
  donnees_filtrees <- subset(resultat, prey_worms_class == classe)
  
  # Calculer le nombre d'individus par famille de proie uniquement pour les données filtrées
  nb_prey_family_filtrees <- table(donnees_filtrees$prey_worms_family)
  
  # Afficher le graphe pour les données filtrées de la classe de proie actuelle
  barplot(nb_prey_family_filtrees, las = 2, cex.names = 0.7, 
          main = paste("Nombre d'individus par famille de proie (", classe, ")"),
          xlab = "Genre de proie", ylab = "Nombre d'individus")
}

```

```{r FAMILY LEVEL}
# Créer un vecteur contenant toutes les classes de proie
toutes_classes <- unique(resultat$prey_worms_class)

# Filtrer les classes de proie qui ne sont pas incluses dans les classes_proie définies
autres_classes <- toutes_classes[!(toutes_classes %in% classes_proie)]

# Ajouter les autres classes à la liste des classes de proie
classes_proie_complet <- c(classes_proie, autres_classes)

# Créer une liste pour stocker les familles dominantes de chaque cluster
familles_plus_1000 <- list()
# Boucle pour filtrer les données et afficher les noms de familles et le nombre d'occurrences pour chaque classe de proie
for (classe in classes_proie_complet) {
  # Filtrer les données en ne considérant que les lignes avec prey_worms_class égale à la classe actuelle
  donnees_filtrees <- subset(resultat, prey_worms_class == classe)
  
  # Calculer le nombre d'individus par famille de proie uniquement pour les données filtrées
  nb_prey_family_filtrees <- table(donnees_filtrees$prey_worms_family)
  
  # Filtrer les familles avec plus de 500 occurrences
  familles_plus_1000[[classe]] <- names(nb_prey_family_filtrees[nb_prey_family_filtrees > 1000])  
  
  # Afficher les noms de familles et le nombre d'occurrences pour la classe de proie actuelle s'ils ont plus de 500 occurrences
  if (length(familles_plus_1000[[classe]]) > 0) {
    cat("Classe de proie:", classe, "\n")
    for (famille in familles_plus_1000[[classe]]) {
      nb_occurrences <- nb_prey_family_filtrees[famille]
      cat("Famille:", famille, "- Nombre d'occurrences:", nb_occurrences, "\n")
    }
    cat("\n")
  } else {
    cat("Classe de proie:", classe, "\n")
    cat("Aucune famille avec plus de 1000 occurrences.\n\n")
  }
}

```

```{r DIET CONTRIBUTION}
# Définir les classes de proie correspondant à chaque cluster
classes_proies <- c("Actinopterygii", "Cephalopoda", "Malacostraca")
# Ajouter une colonne "cluster" en fonction de la classe de proie
resultat$cluster <- ifelse(resultat$prey_worms_class %in% classes_proies, match(resultat$prey_worms_class, classes_proies), 4)

predator_cluster_counts <- resultat %>%
  group_by(predator_name, cluster) %>%
  summarise(count = n())

predator_total_counts <- predator_cluster_counts %>%
  group_by(predator_name) %>%
  summarise(total_count = sum(count))

predator_cluster_percentages <- predator_cluster_counts %>%
  left_join(predator_total_counts, by = "predator_name") %>%
  mutate(percentage = count / total_count * 100)

################################################
```
```{r DIET CONTRIBUTION}
# Liste des familles prédominantes
#actino <- c("Myctophidae", "Nototheniidae", "Channichthyidae")
#malaco <- "Euphausiidae"
#cephalo <- c("Onychoteuthidae", "Cranchiidae", "Ommastrephidae")

familles_predomi = c("Myctophidae", "Nototheniidae", "Channichthyidae","Euphausiidae","Onychoteuthidae", "Cranchiidae", "Ommastrephidae")

predator_family_counts <- resultat %>%
  group_by(predator_name, prey_worms_family) %>%
  summarise(count = n())

predator_total_family_counts <- predator_cluster_counts %>%
  group_by(predator_name) %>%
  summarise(total_count = sum(count))

# Filtrer les lignes du tableau en ne conservant que celles avec une correspondance de nom
predator_family_counts <- subset(predator_family_counts, prey_worms_family %in% familles_predomi)

predator_family_percentages <- predator_family_counts %>%
  left_join(predator_total_counts, by = "predator_name") %>%
  mutate(percentage = count / total_count * 100)

```

```{r PLOT RESULTS - GLOBAL}
library(ggplot2)

# Définition de l'ordre des prédateurs selon la phylogénie
predator_order <- c("Pygoscelis adeliae", "Aptenodytes forsteri", "Aptenodytes patagonicus",
                    "Eudyptes chrysolophus", "Eudyptes schlegeli", "Thalassoica antarctica",
                    "Procellaria aequinoctialis", "Diomedea exulans", "Thalassarche melanophris",
                    "Thalassarche chrysostoma", "Phoebetria fusca", "Phoebetria palpebrata",
                    "Arctocephalus gazella", "Mirounga leonina", "Leptonychotes weddellii",
                    "Megaptera novaeangliae", "Lobodon carcinophaga")

# Création de la liste des noms de cluster correspondant à chaque numéro de cluster
cluster_names <- c("Actinopterygii", "Cephalopoda", "Malacostraca","Others")

# Création du graphique avec la légende personnalisée
global_plot <- ggplot(predator_cluster_percentages, aes(x = factor(predator_name, levels = predator_order), 
                                                        y = percentage, fill = as.factor(cluster))) +
  geom_bar(stat = "identity", position = "fill") +
  labs(x = "Espèce de prédateur", y = "Contribution des clusters de proies", fill = "Clusters de proies") +
  labs(title = "Signature alimentaire des prédateurs (Clusters de proies)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, 
                                   margin = margin(t = 0.6, r = 0, b = 0, l = 0))) +
  scale_fill_manual(values = c('#e41a1c','#377eb8','#4daf4a','#984ea3'),
                    labels = cluster_names)  # Utilisation de la légende personnalisée

# Affichage du graphique
print(global_plot)

library(forcats)

# Iterate over each unique predator species
for (i in unique(predator_cluster_percentages$predator_name)) {
  # Subset the data for the current predator species
  predator_data <- subset(predator_cluster_percentages, predator_name == i)
  
  # Sort the data by percentage in descending order
  predator_data <- predator_data[order(predator_data$percentage, decreasing = TRUE), ]
  
  # Convert the cluster column to a factor
  predator_data$cluster <- as.factor(predator_data$cluster)
  
  # Reorder the prey_worms_family factor based on percentage within each predator species
  predator_data$cluster <- fct_reorder(predator_data$cluster, predator_data$percentage, .desc = TRUE)

  # Create the bar plot for the current predator species
  predator_plot <- ggplot(predator_data, aes(x = cluster, y = percentage, fill = as.factor(cluster))) +   
    geom_bar(stat = "identity") +
    labs(x = "Cluster", y = "Pourcentage", fill = "Cluster") +
    ggtitle(paste("Espèce de prédateur:", i)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, 
                                     margin = margin(t = 0.6, r = 0, b = 0, l = 0)))
  
  # Print the plot for the current predator species
  print(predator_plot)
}

```
```{r PLOT RESULTS - FAMILY}

# Tri des portions de chaque barre par contribution dans l'ordre décroissant
predator_family_percentages <- predator_family_percentages %>%
  arrange(predator_name, desc(percentage)) %>%
  mutate(prey_worms_family = factor(prey_worms_family, levels = unique(prey_worms_family)))

# Création du graphique avec les portions de barre triées par contribution
global_plot <- ggplot(predator_family_percentages, aes(x = factor(predator_name, levels = predator_order), 
                                                      y = percentage, fill = prey_worms_family)) +
  geom_bar(stat = "identity", position = "fill") +
  labs(x = "Espèce de prédateur", y = "Contribution des FM de proies", fill = "FM de proies") +
  labs(title = "Signature alimentaire des prédateurs (Familles majoritaires de proies)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, 
                                   margin = margin(t = 0.6, r = 0, b = 0, l = 0))) +
  scale_fill_manual(values = c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628'),
                    labels = unique(predator_family_percentages$prey_worms_family))  # Utilisation de la légende personnalisée

# Affichage du graphique
print(global_plot)

# Iterate over each unique predator species
for (i in unique(predator_family_percentages$predator_name)) {
  # Subset the data for the current predator species
  predator_data <- subset(predator_family_percentages, predator_name == i)
  
  # Sort the data by percentage in descending order
  predator_data <- predator_data[order(predator_data$percentage, decreasing = TRUE), ]
  
  # Reorder the prey_worms_family factor based on percentage within each predator species
  predator_data$prey_worms_family <- fct_reorder(predator_data$prey_worms_family, predator_data$percentage, .desc = TRUE)
  
  # Create the bar plot for the current predator species
  predator_plot <- ggplot(predator_data, aes(x = prey_worms_family, y = percentage, fill = prey_worms_family)) +
    geom_bar(stat = "identity") +
    labs(x = "Famille de proies", y = "Pourcentage", fill = "Famille de proies") +
    ggtitle(paste("Espèce de prédateur:", i)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, 
                                     margin = margin(t = 0.6, r = 0, b = 0, l = 0)))
  
  # Print the plot for the current predator species
  print(predator_plot)
}

```

```{r CLUSTERS COMPOSITION}
# Create an empty list to store the data frames
prey_list <- list()

# Iterate over each cluster
for (i in 1:4) {  
  # Subset the data for the current cluster
  cluster_data <- resultat[resultat$cluster == i, ]
  
  # Extract the unique prey names for the current cluster
  unique_preys <- unique(cluster_data$prey_name)
  
  # Create a data frame with one column for the prey names
  prey_df <- data.frame(prey = unique_preys)
  
  # Add the data frame to the list
  prey_list[[i]] <- prey_df
}

```
```{r FAMILY COMPOSITION}

prey_list <- list()

# Iterate over each cluster
for (i in familles_predomi) {  
  # Subset the data for the current cluster
  family_data <- resultat[resultat$prey_worms_family == i, ]
  
  # Extract the unique prey names for the current cluster
  unique_preys <- unique(family_data$prey_name)
  
  # Add the unique prey names to the list
  prey_list[[i]] <- unique_preys
}

for(i in seq_along(prey_list)){
  prey_list[[i]] = na.omit(prey_list[[i]])
}
```

```{r GET PREYS OCCURENCES}
# Charger la bibliothèque rgbif
library(rgbif)

for(k in seq_along(prey_list)){
# Vecteur contenant les noms des espèces désirées
species <- prey_list[[k]] # Remplacez par les noms de vos espèces

# Paramètres de recherche
#continent <- "antarctica" # Pays de recherche
limit <- 10000 # Limite du nombre d'occurrences à télécharger (vous pouvez ajuster selon vos besoins)

occurrence_list <- list()

# Boucle pour effectuer la recherche d'occurrences pour chaque espèce
for (i in 1:length(species)) {
  name <- species[i]
  # Check if the name contains a space
  if (grepl(" ", name)) {
    # Species name (two words)
    occurrences <- occ_search(scientificName = name, limit = limit, hasCoordinate = TRUE)
    print(paste("Searching for species:", name))
    # Store the occurrence data in the list
    occurrence_list[[i]] <- occurrences
  } else {
    print(paste("Skipping genus name:", name))
  }
}

# Create an empty list to store the cleaned occurrence data
clean_occ_list <- list()
  
# Iterate over each occurrence data in the list
for (i in seq_along(occurrence_list)) {
  # Retrieve latitude and longitude values from the current occurrence data
  clean_occ <- occurrence_list[[i]]$data
  # Store the cleaned occurrence data in the list
  clean_occ_list[[i]] <- clean_occ
}

# Remove NULL elements from the list
clean_occ_list <- Filter(Negate(is.null), clean_occ_list)

# Create an empty data frame to store the latitude and longitude values
coord_master <- data.frame(latitude = numeric(0), longitude = numeric(0))
  
# Iterate over each occurrence data in the list
for (i in seq_along(clean_occ_list)) {
  # Retrieve latitude and longitude values
  latitude <- clean_occ_list[[i]]$decimalLatitude
  longitude <- clean_occ_list[[i]]$decimalLongitude
  # Create separate rows for each coordinate pair
  for (i in seq_along(latitude)) {
    new_row <- data.frame(latitude = latitude[i], longitude = longitude[i])
    coord_master <- rbind(coord_master, new_row)
  }
}
  
# Reset row names
rownames(coord_master) <- NULL

# Print the resulting data frame
print(coord_master)
plot(coord_master)

filename = paste0("Coords_",names(prey_list[k]),".csv")
write.csv(coord_master, file = filename)
}

```
```{r GET PREYS OCCURENCES}

# Boucle pour effectuer la recherche d'occurrences pour chaque espèce
for (i in 1:length(species)) {
  name <- species[i]
  # Check if the name contains a space
  if (grepl(" ", name)) {
    # Species name (two words)
    occurrences <- occ_search(scientificName = name, continent = continent, limit = limit, hasCoordinate = TRUE)
    print(paste("Searching for species:", name))
    } else {
        # Genus name (single word)
        genus_result <- name_backbone(name)
        if (genus_result$matchType == "NONE") {
          print(paste("No genus key found for name:", name))
          next  # Skip to the next iteration if no genus key is found
        }
        key <- genus_result$usageKey
        occurrences <- occ_search(taxonKey = key, continent = continent, limit = limit, hasCoordinate = TRUE)
        print(paste("Searching for genus:", name))
      }
  # Store the occurrence data in the list
  occurrence_list[[i]] <- occurrences
  }

```

```{r PLOT ALL CLUSTERS}
library(sp)
library(rgdal)
library(SOmap)

basemap = SOmap(l)

# Set the folder path where the files are located
folder_path <- "/Users/charlieplasman/Desktop/Mémoire /HSM/Personal data/Species data/Preys/Automatic"

# Get the list of file names in the folder
file_names <- list.files(path = folder_path, pattern = "*.csv", full.names = F)

# Define colors for each file
colors <- c('#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628') # Add more colors if needed

# Create an empty list to store the results
dataset_list <- list()
# Loop through the CSV files
for (i in seq_along(file_names)) {
  # Read the CSV file
  dataset_list[[i]] <- read.csv(file_names[i])
  # Assign the coordinates and CRS
  coordinates(dataset_list[[i]]) <- c("longitude", "latitude")
  proj4string(dataset_list[[i]]) <- CRS("+proj=longlat +datum=WGS84")
  # Transform the coordinates
  dataset_list[[i]] <- spTransform(dataset_list[[i]], CRS("+proj=longlat +datum=WGS84"))
  # Plot the results with different colors
  plot(basemap)
  SOplot(dataset_list[[i]], col = colors[i])
}
```

```{r INTERSECTION}
# Calculate intersections and store them in a list
intersection_list <- list()

# Outer loop: iterate over each dataset
for (i in 1:(length(dataset_list) - 1)) {
  dataset1 <- dataset_list[[i]]
  
  # Inner loop: iterate over remaining datasets
  for (j in (i + 1):length(dataset_list)) {
    dataset2 <- dataset_list[[j]]
    
    # Calculate the intersection
    intersection <- intersect(dataset1, dataset2)
    
    # Store the intersection in the list
    intersection_list[[paste0("intersection", i, j)]] <- intersection
  }
}

# Plot the intersections
colors <- rainbow(length(intersection_list))
for (i in seq_along(intersection_list)) {
  intersection <- intersection_list[[i]]
  plot(basemap)
  SOplot(intersection, col = colors[i])
}
```

```{r KERNEL DENSITIES}

# Calculate kernel densities for each dataset
density_list <- list()

for (i in seq_along(dataset_list)) {
  dataset <- dataset_list[[i]]
  # Calculate kernel density
  KDE <- MASS::kde2d(dataset$longitude, dataset$latitude, lims = c(-180, 180, -90, -45))
  # Store the density in the list
  density_list[[i]] <- KDE
}

# Plot the kernel densities
colors <- rainbow(length(density_list))
plot(NULL, xlim = c(-180, 180), ylim = c(-90, -45), xlab = "Longitude", ylab = "Latitude",
     main = "Kernel Density Comparison")
for (i in seq_along(density_list)) {
  contour(density_list[[i]], col = colors[i], add = TRUE)
}
legend("topright", legend = c("Myctophidae","Nototheniidae","Channichthyidae","Euphausiidae","Onychoteuthidae","Cranchiidae","Ommastrephidae"), col = colors, lwd = 2, bty = "n")

```

```{r CHI-SQUARED - PRED SPECIES LEVEL}
library(tidyverse)
library(forcats)

# Vecteur avec les noms des espèces de prédateur
studies_species <- unique(resultat$predator_name)
especes <- studies_species
cluster_classes <- c(1, 2, 3, 4, 5)

for (espece in especes) {
  # Filtrer le tableau de données pour l'espèce spécifiée
  filtered_data <- resultat %>%
    filter(predator_name == espece) %>%
    select(cluster) %>%
    filter(cluster %in% cluster_classes) %>%
    mutate(cluster = as.factor(cluster)) %>%
    mutate(cluster = fct_drop(cluster))

  # Calculer les fréquences observées pour chaque cluster
  observed_freq <- table(filtered_data$cluster)

  # Calculer les fréquences attendues avec une répartition égale
  expected_freq <- rep(1/length(levels(filtered_data$cluster)), length(levels(filtered_data$cluster)))

  # Réaliser le test du chi carré pour l'espèce spécifiée
  chi_square_test <- chisq.test(observed_freq, p = expected_freq)

  # Afficher les résultats du test du chi carré pour l'espèce
  cat("Espèce:", espece, "\n")
  print(chi_square_test)
  cat("\n")
}
```


```{r CHI-SQUARED - PREY CLASS LEVEL vs SPECIES - A CORRIGER ATTENTION}

# Calculate the sum of prey counts per cluster
sum_counts <- predator_cluster_percentages %>%
  group_by(cluster) %>%
  summarize(total_count = sum(count))

# Initialize an empty list to store the observed frequencies
observed_freq <- list()

# Iterate over each cluster
for (cluster in cluster_classes) {
  # Filter the data for the current cluster
  filtered_data <- predator_cluster_percentages %>% filter(cluster == cluster)
  
  # Calculate the observed frequencies for the current cluster
  freq <- table(filtered_data$predator)
  
  # Store the observed frequencies in the list
  observed_freq[[as.character(cluster)]] <- freq
}
  

  # Calculer les fréquences attendues avec une répartition égale
  expected_freq <- rep(1/length(levels(filtered_data$cluster)), length(levels(filtered_data$cluster)))

  # Réaliser le test du chi carré pour l'espèce spécifiée
  chi_square_test <- chisq.test(observed_freq, p = expected_freq)

  # Display the results of the chi-square test for the cluster
  cat("Cluster:", cluster, "\n")
  print(chi_square_test)
  cat("\n")
}

```

```{r CHI-SQUARED - PREY CLASS LEVEL vs SPECIES}
# Boucle pour effectuer le test du chi carré pour chaque classe de proie
for (cluster in cluster_classes) {
  # Filtrer le tableau de données pour la classe de proie spécifiée
  filtered_data <- resultat %>%
    filter(cluster == cluster) %>%
    select(predator_name) %>%
    filter(predator_name %in% especes) %>%
    mutate(predator_name = fct_drop(predator_name))
 
  # Réaliser le test du chi carré pour la classe de proie spécifiée
  chi_square_test <- filtered_data %>%
    table() %>%
    chisq.test()
 
  # Afficher les résultats du test du chi carré
  cat("Classe de proie:", cluster, "\n")
  print(chi_square_test)
  cat("\n")
}

```

###
PARTIE 2 : RELATION ENTRE SIGNATURE ALIMENTAIRE ET CONTENU ENERGETIQUE
###

```{r LOAD DATA}

setwd("/Users/charlieplasman/Desktop/Mémoire /HSM/Personal data/Species data")
energy = read.csv("energetics.csv")
#library(sohungry)
#energy = so_energetics()
#write.csv(energy, file = "energetics.csv", row.names = FALSE)

```

```{r VISUALIZE DATA}

prey_class = unique(energy$taxon_worms_class)
nb_prey_class <- table(energy$taxon_worms_class)
print(nb_prey_class)
barplot(nb_prey_class, las = 2, cex.names = 0.7, main = "Nombre d'individus par classe de proie",
        xlab = "Classe de proie", ylab = "Nombre d'individus")

prey_method = unique(energy$measurement_name)
nb_prey_method <- table(energy$measurement_name)
print(nb_prey_method)
barplot(nb_prey_method, las = 2, cex.names = 0.7, main = "Nombre d'individus par mesure",
        xlab = "Type de mesure", ylab = "Nombre d'individus")

```

```{r CLEAN DATA}

#data_rec <- energy %>%
  #mutate(observation_date_start = as.Date(observation_date_start)) %>%
  #filter(year(observation_date_start) >= 1990)

# Sélectionner les variables souhaitées
variables = c("taxon_name","taxon_worms_class",
              "taxon_sample_count","measurement_name",
              "measurement_mean_value","measurement_units","source_id","taxon_sample_id")

data_var = energy[variables]

data_comp <- data_var %>% filter(measurement_name == "energy content")
data_comp <- data_comp %>% filter(measurement_units == "kJ/gWW")
resultat <- data_comp %>% filter(taxon_worms_class == c("Actinopterygii", "Cephalopoda", "Malacostraca", "Teleostei"))

```

```{r VISUALIZE CLEAN DATA}
prey_class = unique(resultat$taxon_worms_class)
nb_prey_class <- table(resultat$taxon_worms_class)
print(nb_prey_class)
barplot(nb_prey_class, las = 2, cex.names = 0.7, main = "Nombre d'individus par classe de proie",
        xlab = "Classe de proie", ylab = "Nombre d'individus")
```


```{r RAREFACTION}

# Déterminez la taille d'échantillon minimale parmi les classes de proies
min_sample_size <- min(table(resultat$taxon_worms_class))

# Réalisez le sous-échantillonnage pour chaque classe de proie
balanced_data <- resultat %>%
  group_by(taxon_worms_class) %>%
  sample_n(min_sample_size, replace = FALSE)

```

```{r MEAN ENERGY CONTENT}

# Calculate the mean of a variable for each prey class
averages <- balanced_data %>%
  group_by(taxon_worms_class) %>%
  summarise(mean_energy = mean(measurement_mean_value),
            variability = sd(measurement_mean_value))
print(averages)
# Plotting the mean energy with error bars
ggplot(averages, aes(x = taxon_worms_class, y = mean_energy)) +
  geom_col(fill = "grey") +
  geom_errorbar(aes(ymin = mean_energy - variability, ymax = mean_energy + variability),
                width = 0.2, color = "black", size = 0.7) +
  labs(x = "Prey Class", y = "Mean Energy content (kJ/gWW)", title = "Mean Energy Content by Prey Class") +
  theme_minimal()

```

```{r KRUSKAL ON MEAN ENERGY CONTENT}

# Perform Shapiro-Wilk test
shapiro_test <- shapiro.test(balanced_data$measurement_mean_value)
# Check the test result
print(shapiro_test)

# Perform Kruskal-Wallis test
kruskal_test <- kruskal.test(measurement_mean_value ~ taxon_worms_class, data = balanced_data)
# Check the test result
print(kruskal_test)

```

```{r CORRELATION BTW EC AND MEAN CONTRIBUTION, PER PREY CLASS}

# Calculer la moyenne d'une variable en fonction du numéro de cluster
mean_by_cluster <- aggregate(percentage ~ cluster, data = predator_cluster_percentages, FUN = mean)
mean_by_cluster = mean_by_cluster[-c(3,5),]
# Afficher les résultats
print(mean_by_cluster)

shapiro_test <- shapiro.test(mean_by_cluster$percentage)
print(shapiro_test)
# Analyse de corrélation
correlation = cor.test(averages$mean_energy, mean_by_cluster$percentage)
# Afficher les résultats de la corrélation
print(correlation)

```

```{r CORRELATION BTW EC AND CONTRIBUTION, BY PREDATOR SPECIES}

clusters_to_remove <- c(3, 5)
by_species <- subset(predator_cluster_percentages, !(cluster %in% clusters_to_remove))
by_species = by_species[,-c(2:4)]

# Trouver les espèces avec exactement 2 lignes dans le tableau
esp_speciales <- by_species %>%
  group_by(predator_name) %>%
  filter(n() == 2) %>%
  distinct(predator_name)

# Parcourir les espèces avec exactement 2 lignes
for (espece_predateur in esp_speciales$predator_name) {
  # Créer une nouvelle ligne avec une contribution de 0
  nouvelle_ligne <- data.frame(predator_name = espece_predateur, percentage = 0)
  
  # Ajouter la nouvelle ligne au tableau existant
  by_species <- bind_rows(by_species, nouvelle_ligne)
}

# Boucle pour itérer sur chaque espèce
for (espece in predator_names) {
  # Sous-tableau contenant les lignes pour l'espèce spécifique
  sous_tableau <- subset(by_species, predator_name == espece)
  
  # Test de Shapiro pour vérifier la normalité
  shapiro_test <- shapiro.test(sous_tableau$percentage)
  
  # Déterminer la méthode de corrélation en fonction du résultat du test de Shapiro
  if (shapiro_test$p.value < 0.05) {
    correlation_method <- "spearman"
  } else {
    correlation_method <- "pearson"
  }
  
  # Test de corrélation entre les contributions et le contenu énergétique
  correlation_test <- cor.test(sous_tableau$percentage, averages$mean_energy, method = correlation_method)
  
  # Afficher les résultats du test pour l'espèce spécifique
  cat("Espèce:", espece, "\n")
  print(correlation_test)
  cat("\n")
}

```

